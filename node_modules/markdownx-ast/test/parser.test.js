/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) {
	            try {
	                step(generator.next(value));
	            } catch (e) {
	                reject(e);
	            }
	        }
	        function rejected(value) {
	            try {
	                step(generator.throw(value));
	            } catch (e) {
	                reject(e);
	            }
	        }
	        function step(result) {
	            result.done ? resolve(result.value) : new P(function (resolve) {
	                resolve(result.value);
	            }).then(fulfilled, rejected);
	        }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const chai_1 = __webpack_require__(1);
	const glob = __webpack_require__(3);
	const os = __webpack_require__(4);
	const io = __webpack_require__(6);
	const path = __webpack_require__(8);
	const parser_1 = __webpack_require__(9);
	function checkError(err) {
	    if (err) {
	        throw err;
	    }
	}
	function checkResult(file, test) {
	    return __awaiter(this, void 0, void 0, function* () {
	        var _ref = yield os.Open(file);
	
	        var _ref2 = _slicedToArray(_ref, 2);
	
	        var r = _ref2[0];
	        var err = _ref2[1];
	
	        checkError(err);
	
	        var _ref3 = yield io.ReadFull(r);
	
	        var _ref4 = _slicedToArray(_ref3, 2);
	
	        var src = _ref4[0];
	        var err = _ref4[1];
	
	        checkError(err);
	        var tree = parser_1.parse(src);
	
	        var _ref5 = yield os.Open(file + ".json");
	
	        var _ref6 = _slicedToArray(_ref5, 2);
	
	        var r = _ref6[0];
	        var err = _ref6[1];
	
	        checkError(err);
	
	        var _ref7 = yield io.ReadFull(r);
	
	        var _ref8 = _slicedToArray(_ref7, 2);
	
	        var resultJSON = _ref8[0];
	        var err = _ref8[1];
	
	        checkError(err);
	        let result = JSON.parse(resultJSON);
	        test(tree, result);
	    });
	}
	const examples = glob.sync("./examples/*.md");
	describe("parser", () => {
	    examples.forEach(example => {
	        it("parses " + path.basename(example), () => {
	            return checkResult(example, chai_1.assert.deepEqual);
	        });
	    });
	});

/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = require("chai");

/***/ },
/* 2 */
/***/ function(module, exports) {

	// Adapted from http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
	// Also see: http://ejohn.org/blog/pure-javascript-html-parser/
	"use strict";
	
	exports.startTagRE = /^<([-A-Za-z0-9_]+)((?:\s+\w+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/;
	const endTagRE = /^<\/([-A-Za-z0-9_]+)[^>]*>/;
	const attrRE = /([-A-Za-z0-9_]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+)))?/g;
	function parseXMLHeredoc(input) {
	    let raw;
	    let remainder = "";
	    const matches = input.match(exports.startTagRE);
	    if (!matches) {
	        return;
	    }
	    raw = matches[0];
	    // console.log(matches);
	    const tagName = matches[1];
	    const tagAttributesString = matches[2] || "";
	    const isSelfClosing = matches[3] === '/';
	    let content;
	    if (!isSelfClosing) {
	        const closeTag = "</" + tagName + ">";
	        const end = input.lastIndexOf(closeTag);
	        content = input.slice(matches[0].length, end);
	        raw += content + closeTag;
	        remainder = input.substring(end + closeTag.length);
	    } else {
	        remainder = input.substring(matches[0].length);
	    }
	    const attrs = parseAttributes(tagAttributesString);
	    const xml = {
	        tag: tagName,
	        attrs: attrs,
	        content: content,
	        raw: raw
	    };
	    return [xml, remainder];
	}
	exports.parseXMLHeredoc = parseXMLHeredoc;
	function parseAttributes(input) {
	    const attrs = {};
	    input.replace(attrRE, function (a0, a1, a2, a3) {
	        const key = a1;
	        let value = a2 || a3 || true;
	        attrs[key] = value;
	        return "";
	    });
	    return attrs;
	}

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = require("glob");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) {
	            try {
	                step(generator.next(value));
	            } catch (e) {
	                reject(e);
	            }
	        }
	        function rejected(value) {
	            try {
	                step(generator.throw(value));
	            } catch (e) {
	                reject(e);
	            }
	        }
	        function step(result) {
	            result.done ? resolve(result.value) : new P(function (resolve) {
	                resolve(result.value);
	            }).then(fulfilled, rejected);
	        }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const fs = __webpack_require__(5);
	// import * as stream from "stream";
	const io = __webpack_require__(6);
	function waitFSOpen(stream) {
	    return __awaiter(this, void 0, void 0, function* () {
	        return new Promise(done => {
	            function onError(err) {
	                done(err);
	            }
	            stream.once("error", onError);
	            stream.once("open", () => {
	                stream.removeListener("error", onError);
	                done(null);
	            });
	        });
	    });
	}
	function Open(file, options) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const stream = fs.createReadStream(file, options);
	        const err = yield waitFSOpen(stream);
	        return [new io.StreamReader(stream), err];
	    });
	}
	exports.Open = Open;
	// Create creates the named file with mode 0666 (before umask), truncating it if it already exists.
	function Create(file, options) {
	    return __awaiter(this, void 0, void 0, function* () {
	        const stream = fs.createWriteStream(file, options);
	        const err = yield waitFSOpen(stream);
	        return [new io.StreamWriter(stream), err];
	    });
	}
	exports.Create = Create;

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) {
	            try {
	                step(generator.next(value));
	            } catch (e) {
	                reject(e);
	            }
	        }
	        function rejected(value) {
	            try {
	                step(generator.throw(value));
	            } catch (e) {
	                reject(e);
	            }
	        }
	        function step(result) {
	            result.done ? resolve(result.value) : new P(function (resolve) {
	                resolve(result.value);
	            }).then(fulfilled, rejected);
	        }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	exports.EOF = new Error("EOF");
	// interface Closer {
	//   Close(): Promise<error>;
	// }
	// Not knowing whether it's going to return Buffer or string is annoying...
	// Use buffer by default. wth.
	// You know what? this is pretty insane. I wonder if I could simply interface with the native read stream.
	class StreamReader {
	    constructor(stream) {
	        this.currentReadResolve = null;
	        this.currentRead = null;
	        this.closed = false;
	        this.err = null;
	        // throw a hissy fit if an encoding is used...
	        this.stream = stream;
	        this.stream.on("readable", () => __awaiter(this, void 0, void 0, function* () {
	            // should only try to read where Read is called..
	            yield this.pendingRead;
	            const chunk = this.stream.read();
	            // console.log("stream.read",chunk);
	            if (chunk == null) {
	                // Not enough data. Wait for next readable event.
	                // We also get null for EOF. In which case, let `end` event resolve to read.
	                return;
	            }
	            // read -> chunk
	            // read -> null
	            // stream -> end
	            this.resolveRead(chunk, null);
	        }));
	        this.stream.on("error", err => {
	            // console.log("stream error",err);
	            this.err = err;
	            this.resolveRead(null, err);
	        });
	        this.stream.on("end", () => {
	            // console.log("stream end");
	            this.closed = true;
	            this.resolveRead(null, exports.EOF);
	        });
	        this.createPendingRead();
	    }
	    resolveRead(chunk, error) {
	        // debugger;
	        if (this.currentRead == null) {
	            return;
	        }
	        this.currentRead = null;
	        let resolve = this.currentReadResolve;
	        resolve([chunk, error]);
	        if (!this.closed) {
	            this.createPendingRead();
	        }
	    }
	    createPendingRead() {
	        this.pendingRead = new Promise(resolve => {
	            this.pendingReadResolve = resolve;
	        });
	    }
	    triggerPendingRead() {
	        this.pendingReadResolve();
	    }
	    Read() {
	        return __awaiter(this, void 0, void 0, function* () {
	            let readPromise = new Promise(resolve => __awaiter(this, void 0, void 0, function* () {
	                // Serialize reads
	                while (true) {
	                    if (this.currentRead == null) {
	                        break;
	                    }
	                    yield this.currentRead;
	                }
	                if (this.closed) {
	                    resolve([null, exports.EOF]);
	                    return;
	                }
	                if (this.err) {
	                    resolve([null, this.err]);
	                    return;
	                }
	                // ensure that we capture readPromise after it's set...
	                process.nextTick(() => {
	                    // debugger;
	                    this.currentRead = readPromise;
	                    this.currentReadResolve = resolve;
	                    this.triggerPendingRead();
	                });
	            }));
	            return readPromise;
	        });
	    }
	}
	exports.StreamReader = StreamReader;
	class StreamWriter {
	    constructor(stream) {
	        this.closed = false;
	        this.err = null;
	        // throw a hissy fit if an encoding is used...
	        this.stream = stream;
	        this.stream.on("finish", () => {
	            this.closed = true;
	        });
	        this.stream.on("error", Err => {
	            this.err = Err;
	        });
	    }
	    Write(chunk) {
	        return __awaiter(this, void 0, void 0, function* () {
	            if (this.err || this.closed) {
	                return;
	            }
	            return new Promise(done => {
	                this.stream.write(chunk, () => {
	                    // This callback will be called regardless of success or error.
	                    // The error callback is guranteed to be called before the write callback (looking at stream.Writable's code).
	                    done(this.err);
	                });
	            });
	        });
	    }
	    Close() {
	        return __awaiter(this, void 0, void 0, function* () {
	            if (this.closed) {
	                return;
	            }
	            if (this.err) {
	                return this.err;
	            }
	            return new Promise(resolve => {
	                this.stream.once("finish", () => {
	                    resolve(this.err);
	                });
	            });
	        });
	    }
	}
	exports.StreamWriter = StreamWriter;
	class StreamReadWriteCloser {
	    constructor(stream) {
	        this.w = new StreamWriter(stream);
	        this.r = new StreamReader(stream);
	    }
	    Write(chunk) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.w.Write(chunk);
	        });
	    }
	    Read() {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.r.Read();
	        });
	    }
	    Close() {
	        return __awaiter(this, void 0, void 0, function* () {
	            return this.w.Close();
	        });
	    }
	}
	exports.StreamReadWriteCloser = StreamReadWriteCloser;
	const string_decoder_1 = __webpack_require__(7);
	function ReadFull(r) {
	    let encoding = arguments.length <= 1 || arguments[1] === undefined ? "utf8" : arguments[1];
	
	    return __awaiter(this, void 0, void 0, function* () {
	        let all = "";
	        // let all = new Buffer();
	        let decoder = new string_decoder_1.StringDecoder(encoding);
	        while (true) {
	            var _ref = yield r.Read();
	
	            var _ref2 = _slicedToArray(_ref, 2);
	
	            let chunk = _ref2[0];
	            let err = _ref2[1];
	            // console.log("chunk", chunk, err);
	
	            if (err === exports.EOF) {
	                break;
	            }
	            if (err) {
	                return ["", err];
	            }
	            all += decoder.write(chunk);
	        }
	        // console.log("done read all");
	        // end method not in node.d.ts
	        all += decoder.end();
	        return [all, null];
	    });
	}
	exports.ReadFull = ReadFull;
	// function SplitBytes() {
	// }
	// class BufferSplitter {
	// }
	// class StringSplitter {
	//   private buf: string = "";
	//   private r: Reader;
	//   private decoder: NodeStringDecoder;
	//   //
	//   constructor(r: Reader, encoding = "utf8") {
	//     this.r = r;
	//     this.decoder = new StringDecoder(encoding);
	//   }
	//   async Next(delimiter: RegExp): Promise<[string,error]> {
	//     while(true) {
	//       if(this.buf == "") {
	//         let [chunk,err] = await this.r.Read();
	//         this.buf += this.decoder.write(chunk);
	//       }
	//     }
	//     let start = piece.indexOf(delimiter);
	//     if(start != -1) {
	//       let end = start + delimiter.length;
	//       let beforeDelimiter = piece.slice(0,start);
	//       let afterDelimiter = piece.slice(end);
	//       let
	//     }
	//   }
	// }
	// async () => {
	//   let splitter = r.Split("\n")
	//   await splitter.Next();
	//   await splitter.Each(line => {
	//   });
	//   let lines = await splitter.Map(line => {
	//   });
	//   // for(let line of ) {
	//   //   let line = await line;
	//   // }
	// }

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = require("string_decoder");

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	// let sectionize = require("./sectionize");
	"use strict";
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }
	
	var _require = __webpack_require__(10);
	
	let lexer = _require.lexer;
	
	var _require2 = __webpack_require__(11);
	
	let makeEnsureUnique = _require2.makeEnsureUnique;
	
	const ast = __webpack_require__(13);
	const tk = __webpack_require__(14);
	const inline_1 = __webpack_require__(15);
	const NodeTypes = ast.NodeTypes;
	
	const parseXMLHeredoc_1 = __webpack_require__(2);
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = parse;
	function parse(src) {
	    let tokens = tokenize(src);
	    let sections = _parse(tokens);
	    return sections;
	}
	exports.parse = parse;
	function tokenize(src) {
	    return lexer(src);
	}
	exports.tokenize = tokenize;
	function _parse(tokens) {
	    let sections = [];
	    let ensureUnique = makeEnsureUnique();
	    // dup tokens
	    tokens = tokens.reverse();
	    function popToken() {
	        return tokens.pop();
	    }
	    function peekToken() {
	        if (tokens.length == 0) {
	            return null;
	        }
	        return tokens[tokens.length - 1];
	    }
	    function parseListItem() {
	        const start = popToken();
	        let children;
	        if (start.type === tk.Types.loose_item_start) {
	            // Kludgy handling of "loose items". The tokens returned by the lexer are messy to begin with.
	            children = parseContent(tk.Types.list_item_end, [], true).map(node => {
	                if (typeof node === "string") {
	                    // Add space to prevent text strings from being joined together.
	                    return node + " ";
	                } else {
	                    if (node.type === "space") {
	                        const newline = {
	                            type: "newline"
	                        };
	                        return newline;
	                    } else {
	                        return node;
	                    }
	                }
	            });
	        } else {
	            children = parseContent(tk.Types.list_item_end);
	        }
	        popToken(); // list_item_end
	        return {
	            type: NodeTypes.list_item,
	            children: children
	        };
	    }
	    function parseList() {
	        // "list_start"
	
	        var _popToken = popToken();
	
	        let ordered = _popToken.ordered;
	
	        let items = [];
	        while (tokens.length > 0) {
	            let token = peekToken();
	            let type = token.type;
	
	            if (type === tk.Types.list_end) {
	                popToken();
	                break;
	            } else if (tk.isListItemStartToken(token)) {
	                items.push(parseListItem());
	            }
	        }
	        return { type: NodeTypes.list, ordered: ordered, items: items };
	    }
	    function parseBlockQuote() {
	        popToken(); // blockquote_start
	        let children = parseContent(tk.Types.blockquote_end);
	        popToken(); // blockquote_end
	        return {
	            type: "blockquote",
	            children: children
	        };
	    }
	    function parseSection() {
	        let token = peekToken();
	        let id;
	        let heading;
	        let content = [];
	        if (token.type === tk.Types.heading) {
	            let headingToken = token;
	            heading = parseHeading();
	            id = heading.id;
	            content.push(heading);
	        } else {
	            id = "_top";
	        }
	        parseContent(ast.NodeTypes.heading, content);
	        return {
	            type: NodeTypes.section,
	            children: content,
	            id: id
	        };
	    }
	    function parseHeading() {
	        let token = tokens.pop();
	        let id = ensureUnique(token.text);
	        return {
	            id: id,
	            type: ast.NodeTypes.heading,
	            depth: token.depth,
	            text: token.text
	        };
	    }
	    function parseParagraph() {
	        let token = tokens.pop();
	        return {
	            type: "paragraph",
	            children: inline_1.parseInline(token.text)
	        };
	    }
	    // Treat uppercase HTML tags as components. Parse text content recursively.
	    function parseComponent() {
	        var _tokens$pop = tokens.pop();
	
	        const text = _tokens$pop.text;
	
	        var _parseXMLHeredoc_1$pa = parseXMLHeredoc_1.parseXMLHeredoc(text);
	
	        var _parseXMLHeredoc_1$pa2 = _slicedToArray(_parseXMLHeredoc_1$pa, 2);
	
	        const doc = _parseXMLHeredoc_1$pa2[0];
	        const _ = _parseXMLHeredoc_1$pa2[1];
	        const tag = doc.tag;
	        const attrs = doc.attrs;
	        const content = doc.content;
	
	        const node = {
	            type: "jsx",
	            name: tag,
	            attrs: attrs
	        };
	        if (content) {
	            node.sections = parse(content);
	        }
	        return node;
	    }
	    function parseContent(endType) {
	        let content = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
	        let preserveSpace = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	
	        // let content: Node[] = [];
	        while (true) {
	            let token = peekToken();
	            if (token == null) {
	                return content;
	            }
	            if (token.type == endType) {
	                return content;
	            }
	            // Get rid of space, except when it matters (list items...)
	            if (token.type === "space" && !preserveSpace) {
	                tokens.pop();
	                continue;
	            }
	            if (tk.isListStartToken(token)) {
	                content.push(parseList());
	            } else if (tk.isText(token)) {
	                tokens.pop();
	                let children = inline_1.parseInline(token.text);
	                content.push.apply(content, _toConsumableArray(children));
	            } else if (token.type === tk.Types.paragraph) {
	                content.push(parseParagraph());
	            } else if (token.type === tk.Types.heading) {
	                content.push(parseHeading());
	            } else if (token.type === tk.Types.blockquote_start) {
	                content.push(parseBlockQuote());
	            } else if (token.type === tk.Types.html) {
	                const text = token.text;
	
	                if (text.match(/^<[A-Z]/)) {
	                    // treat uppercase tags as components
	                    content.push(parseComponent());
	                } else {
	                    // normal html node
	                    content.push(tokens.pop());
	                }
	            } else {
	                content.push(tokens.pop());
	            }
	        }
	    }
	    while (tokens.length > 0) {
	        sections.push(parseSection());
	    }
	    // createSection();
	    return sections;
	}

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = require("marked");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	// let {kebabCase} = require("lodash");
	
	const lodash_1 = __webpack_require__(12);
	function makeEnsureUnique() {
	    let ids = {};
	    return function ensureUnique(str) {
	        let id = lodash_1.kebabCase(str);
	        let i = 1;
	        while (true) {
	            let tryId = id;
	            if (i != 1) {
	                tryId = tryId + "_" + i;
	            }
	            if (ids[tryId] == null) {
	                id = tryId;
	                ids[id] = true;
	                break;
	            }
	            i++;
	        }
	        return id;
	    };
	}
	exports.makeEnsureUnique = makeEnsureUnique;
	function pp(obj) {
	    console.log(JSON.stringify(obj, undefined, 2));
	    return obj;
	}
	exports.pp = pp;
	function hashCode(str) {
	    if (str == null || str.charCodeAt == null) {
	        return 0;
	    }
	    var hash = 0,
	        i,
	        chr,
	        len;
	    if (str.length == 0) return hash;
	    for (i = 0, len = str.length; i < len; i++) {
	        chr = str.charCodeAt(i);
	        hash = (hash << 5) - hash + chr;
	        hash |= 0; // Convert to 32bit integer
	    }
	    return hash;
	}
	exports.hashCode = hashCode;
	;

/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = require("lodash");

/***/ },
/* 13 */
/***/ function(module, exports) {

	// Abstract Sytnax Tree for Markdown Document
	"use strict";
	
	exports.NodeTypes = {
	    document: "document",
	    heading: "heading",
	    section: "section",
	    list: "list",
	    list_item: "list-item",
	    paragraph: "paragraph",
	    code: "code",
	    html: "html",
	    jsx: "jsx",
	    i18n: "i18n",
	    blockquote: "blockquote",
	    newline: "newline"
	};
	function isIdNode(o) {
	    return o.id != null;
	}
	exports.isIdNode = isIdNode;
	function isTextNode(o) {
	    return o.text != null;
	}
	exports.isTextNode = isTextNode;
	;
	function isListItem(o) {
	    return o.type == exports.NodeTypes.list_item;
	}
	exports.isListItem = isListItem;
	function isList(o) {
	    return o.type == exports.NodeTypes.list;
	}
	exports.isList = isList;

/***/ },
/* 14 */
/***/ function(module, exports) {

	// The objects returned by marked lexer.
	"use strict";
	
	exports.Types = {
	    heading: "heading",
	    list_start: "list_start",
	    list_end: "list_end",
	    paragraph: "paragraph",
	    list_item_start: "list_item_start",
	    loose_item_start: "loose_item_start",
	    list_item_end: "list_item_end",
	    blockquote_start: "blockquote_start",
	    blockquote_end: "blockquote_end",
	    html: "html",
	    text: "text"
	};
	function isText(t) {
	    return t.type === exports.Types.text;
	}
	exports.isText = isText;
	function isListStartToken(token) {
	    return token.type == exports.Types.list_start;
	}
	exports.isListStartToken = isListStartToken;
	function isListItemStartToken(token) {
	    return token.type == exports.Types.list_item_start || token.type == exports.Types.loose_item_start;
	}
	exports.isListItemStartToken = isListItemStartToken;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	const marked = __webpack_require__(10);
	const options = Object.assign(marked.defaults, { xhtml: true });
	const inlineLexer = new marked.InlineLexer([], options);
	const parseXMLHeredoc_1 = __webpack_require__(2);
	const parser_1 = __webpack_require__(9);
	inlineLexer.outputAST = outputAST;
	function parseInline(src) {
	    return inlineLexer.outputAST(src);
	}
	exports.parseInline = parseInline;
	function outputAST(src) {
	    var items = [];
	    var out = '';
	    var link, text, href, cap;
	    function pushTextItem() {
	        items.push(out);
	        out = "";
	    }
	    function pushNode(node) {
	        pushTextItem();
	        items.push(node);
	    }
	    while (src) {
	        // escape
	        if (cap = this.rules.escape.exec(src)) {
	            src = src.substring(cap[0].length);
	            out += cap[1];
	            continue;
	        }
	        // autolink
	        // if (cap = this.rules.autolink.exec(src)) {
	        //   src = src.substring(cap[0].length);
	        //   if (cap[2] === '@') {
	        //     text = cap[1].charAt(6) === ':'
	        //       ? this.mangle(cap[1].substring(7))
	        //       : this.mangle(cap[1]);
	        //     href = this.mangle('mailto:') + text;
	        //   } else {
	        //     text = escape(cap[1]);
	        //     href = text;
	        //   }
	        //   out += this.renderer.link(href, null, text);
	        //   continue;
	        // }
	        // // url (gfm)
	        // if (!this.inLink && (cap = this.rules.url.exec(src))) {
	        //   src = src.substring(cap[0].length);
	        //   text = escape(cap[1]);
	        //   href = text;
	        //   out += this.renderer.link(href, null, text);
	        //   continue;
	        // }
	        // // tag
	        // if (cap = this.rules.tag.exec(src)) {
	        //   if (!this.inLink && /^<a /i.test(cap[0])) {
	        //     this.inLink = true;
	        //   } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
	        //     this.inLink = false;
	        //   }
	        //   src = src.substring(cap[0].length);
	        //   out += this.options.sanitize
	        //     ? this.options.sanitizer
	        //       ? this.options.sanitizer(cap[0])
	        //       : escape(cap[0])
	        //     : cap[0]
	        //   continue;
	        // }
	        if (cap = this.rules.tag.exec(src)) {
	            var _parseXMLHeredoc_1$pa = parseXMLHeredoc_1.parseXMLHeredoc(src);
	
	            var _parseXMLHeredoc_1$pa2 = _slicedToArray(_parseXMLHeredoc_1$pa, 2);
	
	            const result = _parseXMLHeredoc_1$pa2[0];
	            const remainder = _parseXMLHeredoc_1$pa2[1];
	
	            src = remainder;
	            const firstLetter = result.tag.charAt(0);
	            const isTagFirstLetterUppercase = firstLetter.toUpperCase() == firstLetter;
	            if (!isTagFirstLetterUppercase) {
	                const node = {
	                    type: "html",
	                    pre: false,
	                    text: result.raw
	                };
	                pushNode(node);
	            } else {
	                const node = {
	                    type: "jsx",
	                    name: result.tag,
	                    attrs: result.attrs,
	                    sections: parser_1.parse(result.content)
	                };
	                pushNode(node);
	            }
	            continue;
	        }
	        // // link
	        // if (cap = this.rules.link.exec(src)) {
	        //   src = src.substring(cap[0].length);
	        //   this.inLink = true;
	        //   out += this.outputLink(cap, {
	        //     href: cap[2],
	        //     title: cap[3]
	        //   });
	        //   this.inLink = false;
	        //   continue;
	        // }
	        // link
	        if (cap = this.rules.link.exec(src)) {
	            src = src.substring(cap[0].length);
	            var _cap = cap;
	
	            var _cap2 = _slicedToArray(_cap, 4);
	
	            const _ = _cap2[0];
	            const caption = _cap2[1];
	            const href = _cap2[2];
	            const title = _cap2[3];
	
	            if (cap[0].charAt(0) === "!") {
	                let node = {
	                    type: "image",
	                    caption: caption,
	                    href: href
	                };
	                if (title) {
	                    node.title = title;
	                }
	                pushNode(node);
	            } else {
	                let node = {
	                    type: "link",
	                    caption: caption,
	                    href: href
	                };
	                if (title) {
	                    node.title = title;
	                }
	                pushNode(node);
	            }
	            continue;
	        }
	        // // reflink, nolink
	        // if ((cap = this.rules.reflink.exec(src))
	        //     || (cap = this.rules.nolink.exec(src))) {
	        //   src = src.substring(cap[0].length);
	        //   link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
	        //   link = this.links[link.toLowerCase()];
	        //   if (!link || !link.href) {
	        //     out += cap[0].charAt(0);
	        //     src = cap[0].substring(1) + src;
	        //     continue;
	        //   }
	        //   this.inLink = true;
	        //   out += this.outputLink(cap, link);
	        //   this.inLink = false;
	        //   continue;
	        // }
	        // // strong
	        // if (cap = this.rules.strong.exec(src)) {
	        //   src = src.substring(cap[0].length);
	        //   out += this.renderer.strong(this.output(cap[2] || cap[1]));
	        //   continue;
	        // }
	        // strong
	        if (cap = this.rules.strong.exec(src)) {
	            src = src.substring(cap[0].length);
	            let node = {
	                type: "strong",
	                text: cap[2] || cap[1]
	            };
	            pushNode(node);
	            continue;
	        }
	        // // em
	        // if (cap = this.rules.em.exec(src)) {
	        //   src = src.substring(cap[0].length);
	        //   out += this.renderer.em(this.output(cap[2] || cap[1]));
	        //   continue;
	        // }
	        if (cap = this.rules.em.exec(src)) {
	            src = src.substring(cap[0].length);
	            let node = {
	                type: "emphasis",
	                text: cap[2] || cap[1]
	            };
	            pushNode(node);
	            continue;
	        }
	        // code
	        // if (cap = this.rules.code.exec(src)) {
	        //   src = src.substring(cap[0].length);
	        //   out += this.renderer.codespan(escape(cap[2], true));
	        //   continue;
	        // }
	        // code
	        if (cap = this.rules.code.exec(src)) {
	            src = src.substring(cap[0].length);
	            let node = {
	                type: "inline-code",
	                text: cap[2]
	            };
	            pushNode(node);
	            continue;
	        }
	        // // br
	        // if (cap = this.rules.br.exec(src)) {
	        //   src = src.substring(cap[0].length);
	        //   out += this.renderer.br();
	        //   continue;
	        // }
	        // // del (gfm)
	        // if (cap = this.rules.del.exec(src)) {
	        //   src = src.substring(cap[0].length);
	        //   out += this.renderer.del(this.output(cap[1]));
	        //   continue;
	        // }
	        // Accmulate into string.
	        if (cap = this.rules.text.exec(src)) {
	            src = src.substring(cap[0].length);
	            // out += this.renderer.text(escape(this.smartypants(cap[0])));
	            out += cap[0];
	            continue;
	        }
	        if (src) {
	            throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
	        }
	    }
	    if (out != "") {
	        pushTextItem();
	    }
	    return items;
	    // return out;
	}
	;
	function escape(html, encode) {
	    return html.replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
	}

/***/ }
/******/ ]);
//# sourceMappingURL=parser.test.js.map